📚 資料結構：線性表（陣列）考研真題精選筆記
📌 核心考點與工具箱
雙指標 (Two Pointers)：用於原地修改、去重或尋找特定組合。
三次逆置法 (Triple Reverse)：解決所有「旋轉」、「區塊交換」問題。
二分搜尋 (Divide & Conquer)：將 $O(n)$ 優化至 $O(\log n)$ 的利器。
空間換時間：利用輔助陣列（雜湊思想）達到 $O(n)$ 時間複雜度。
📝 題目與解答詳解
01. 有序表去重 (In-place Remove Duplicates)
題目描述：從有序順序表中刪除所有其值重複的元素，使表中所有元素的值均不同。
演算法思想：利用有序性，相同的元素必相鄰。將第一個元素視為非重複序列起點，依序判斷後續元素是否與當前非重複序列最後一個元素相同。
程式解答：
```cpp
bool Delete_Same(SeqList &L) {
    if (L.length == 0) return false;
    int i = 0; // 記錄非重複序列的末尾
    for (int j = 1; j < L.length; j++) {
        if (L.data[i] != L.data[j]) { // 發現新元素
            L.data[++i] = L.data[j];  // 移至下一個位置
        }
    }
    L.length = i + 1; // 更新長度
    return true;
}
```

複雜度：時間 $O(n)$，空間 $O(1)$。
標籤：#雙指標 #有序表
02. 兩段順序表位置互換 (2010 統考真題變體)
題目描述：已知在一維陣列 $A[m+n]$ 中依次存放兩個線性表 $(a_1, a_2, \dots, a_m)$ 和 $(b_1, b_2, \dots, b_n)$。試編寫一個函數，將陣列中兩個順序表的位置互換。
演算法思想：先將兩個子表分別逆置，最後再將整個陣列逆置。
程式解答：
```cpp
void Reverse(int A[], int left, int right) {
    while (left < right) {
        int temp = A[left];
        A[left++] = A[right];
        A[right--] = temp;
    }
}
void Exchange(int A[], int m, int n) {
    Reverse(A, 0, m - 1);         // 逆置前 m 個
    Reverse(A, m, m + n - 1);     // 逆置後 n 個
    Reverse(A, 0, m + n - 1);     // 全體逆置
}
```

複雜度：時間 $O(m+n)$，空間 $O(1)$。
標籤：#三次逆置 #區塊交換
03. 兩個等長升序序列的中位數 (2011 統考真題)
題目描述：一個長度為 $L$ 的升序序列 $S$。現有兩個等長升序序列 $A$ 和 $B$，試設計一個在時間和空間兩方面都盡可能高效的算法，找出兩個序列合併後的中位數。
演算法思想：分別計算兩序列的中位數 $a$ 和 $b$。若 $a < b$，則中位數必在 $A$ 的後半段與 $B$ 的前半段中；反之亦然。重複縮減規模直到各剩一個元素。
程式解答：
```cpp
int SearchMedian(int A[], int B[], int n) {
    int s1 = 0, d1 = n - 1, s2 = 0, d2 = n - 1;
    while (s1 != d1) {
        int m1 = (s1 + d1) / 2, m2 = (s2 + d2) / 2;
        if (A[m1] == B[m2]) return A[m1];
        if (A[m1] < B[m2]) {
            s1 = ((s1 + d1) % 2 == 0) ? m1 : m1 + 1;
            d2 = m2;
        } else {
            d1 = m1;
            s2 = ((s2 + d2) % 2 == 0) ? m2 : m2 + 1;
        }
    }
    return A[s1] < B[s2] ? A[s1] : B[s2];
}
```

複雜度：時間 $O(\log n)$，空間 $O(1)$。
標籤：#二分搜尋 #中位數
04. 尋找陣列主元素 (2013 統考真題)
題目描述：若存在 $a_{p1} = a_{p2} = \dots = a_{pm} = x$ 且 $m > n/2$，則稱 $x$ 為 $A$ 的主元素。找出 $A$ 中的主元素，若不存在則輸出 -1。
演算法思想：摩爾投票法。第一遍掃描找出候選主元素（抵消思想）；第二遍掃描統計該元素實際出現次數以驗證。
程式解答：
```cpp
int Majority(int A[], int n) {
    int cand = A[0], count = 1;
    for (int i = 1; i < n; i++) { // 投票階段
        if (A[i] == cand) count++;
        else if (count > 0) count--;
        else { cand = A[i]; count = 1; }
    }
    count = 0;
    for (int i = 0; i < n; i++) if (A[i] == cand) count++; // 確認階段
    return (count > n / 2) ? cand : -1;
}
```

複雜度：時間 $O(n)$，空間 $O(1)$。
標籤：#摩爾投票 #主元素
05. 缺失的最小正整數 (2018 統考真題)
題目描述：給定一個含 $n$ 個整數的陣列，找數組中未出現的最小正整數。例如，$\{-5, 3, 2, 3\}$ 未出現的最小正整數是 1。
演算法思想：使用一個長度為 $n$ 的輔助陣列標記 $1 \sim n$ 是否出現過。第一個未被標記的下標 $+1$ 即為答案。
程式解答：
```cpp
int FindMissMin(int A[], int n) {
    int *B = (int *)malloc(sizeof(int) * n); // 輔助陣列
    memset(B, 0, sizeof(int) * n);
    for (int i = 0; i < n; i++)
        if (A[i] > 0 && A[i] <= n) B[A[i] - 1] = 1; // 標記出現過的數字
    for (int i = 0; i < n; i++)
        if (B[i] == 0) return i + 1; // 找到第一個缺席者
    return n + 1;
}
```

複雜度：時間 $O(n)$，空間 $O(n)$。
標籤：#輔助陣列 #雜湊思想
06. 三元組最小距離 (2020 統考真題)
題目描述：定義三元組 $(a, b, c)$ 的距離 $D = |a-b| + |b-c| + |c-a|$。設計一個算法計算三元組 $(a \in S_1, b \in S_2, c \in S_3)$ 的最小距離。
演算法思想：$D$ 其實等於 $2 \times (\max(a, b, c) - \min(a, b, c))$。使用三個指標分別遍歷，每次僅移動指向最小值的指標，以尋求縮小差距。
程式解答：
```cpp
int Min_Distance(int S1[], int n1, int S2[], int n2, int S3[], int n3) {
    int i = 0, j = 0, k = 0, min_dist = INT_MAX;
    while (i < n1 && j < n2 && k < n3) {
        int D = abs(S1[i] - S2[j]) + abs(S2[j] - S3[k]) + abs(S3[k] - S1[i]);
        if (D < min_dist) min_dist = D;
        // 移動最小值的指標
        if (S1[i] <= S2[j] && S1[i] <= S3[k]) i++;
        else if (S2[j] <= S1[i] && S2[j] <= S3[k]) j++;
        else k++;
    }
    return min_dist;
}
```

複雜度：時間 $O(n_1 + n_2 + n_3)$，空間 $O(1)$。
標籤：#三指標 #貪婪策略
🏷️ 筆記分類標籤
#資料結構 #考研衝刺 #順序表 #2025考研 #演算法詳解 #真題分析
