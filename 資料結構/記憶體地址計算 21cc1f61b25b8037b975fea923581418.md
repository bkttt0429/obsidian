# 記憶體地址計算

上次編輯時間: 2025年10月18日 下午4:57
建立時間: 2025年6月24日 下午4:34

---

# 一、位址計算

## 1) 名詞

- 在台灣：直的稱「行」，橫的稱「列」。
- 在中國大陸：直的稱「列」，橫的稱「行」。

**列（row）**

- **視覺排列**：**橫向**排布
- **堆疊方向**：**往下疊** → **決定高度**
- **索引**：`i`（row index）
- **記憶體鄰接**：在 **row-major**（C/C++、Python NumPy 預設）→ **同一行(橫向)連續**
    
    > 在 column-major（Fortran/Matlab/Julia）不一定同行連續
    > 

**行（column）**

- **視覺排列**：**縱向**排布
- **擴展方向**：**往右展** → **決定寬度**
- **索引**：`j`（column index）
- **記憶體鄰接**：在 **column-major**（Fortran/Matlab/Julia）→ **同一列(縱向)連續**
    
    > 在 row-major（C/C++ 等）不一定同列連續
    > 
    

## 2) 一維陣列位址

$\text{Loc}(A[k])=\text{Base}+k\cdot d$

- `Base = loc(A)` 起始位址（A[0]）
- `d = sizeof(Element)`

## 3) 二維陣列位址（**支援任意下界**）

令陣列索引為 $[r_L:r_U]\times[c_L:c_U]$，

- Rows =$R=r_U-r_L+1$
- Cols =$C=c_U-c_L+1$
- 元素大小 d

### Row-major（行主序）

 $\boxed{\ \text{Loc}(A[i,j])=\text{Base}+\big((i-r_L)\cdot C+(j-c_L)\big)\cdot d\ }$

### Column-major（列主序）

$\boxed{\ \text{Loc}(A[i,j])=\text{Base}+\big((j-c_L)\cdot R+(i-r_L)\big)\cdot d\ }$

> 口訣：Row-major 先「行位移」再加列偏移；Column-major 先「列位移」再加行偏移。
> 

---

# 二、例題（校對版）

### Q1

`Array(-4:3, -3:2)`，`A(-4,-3)=100`，`d=1`，Row-major，求 `Loc(A[1,1])`

- $R=8,C=6R=8, C=6，rL=−4,cL=−3r_L=-4, c_L=-3$

$\text{Loc}=100+((1-(-4))\cdot 6+(1-(-3)))\cdot 1
=100+(5\cdot 6+4)=\boxed{134}$

### Q2 由兩點判斷儲存方式

已知 `d=4`、`Loc(A[1,1])=1204`、`Loc(A[3,3])=1244`，判斷 Row/Column-major 並估 R 或 C。

- 設 Base = 1204（視為 A[1,1]A[1,1] 的位址）

**若 Row-major**

$1244=1204+\big((3-1)\cdot C+(3-1)\big)\cdot 4
\Rightarrow 40=(2C+2)\cdot 4\Rightarrow 2C+2=10\Rightarrow C=4$

可行 → **Row-major 並且 C=4C=4**。（也可反向檢 Column-major 是否整除。）

> 你圖中的試算「1204+((4−1)×4+(4−1))×4=1264」是在檢交點是否吻合的思路，整理如上即可。
> 

### Q3

`A(1:m,1:n)`，**實際證明 Row-major 不可能**，改用 Column-major：

- 已知：`Loc(A[3,3])=121`、`Loc(A[6,4])=159`、`d=1`
- Column-major：

$159=121+\big((4-3)\cdot m+(6-3)\big)\cdot 1\Rightarrow 38=m+3\Rightarrow m=\boxed{35}$

$\text{Loc}(A[5,4])=121+((4-3)\cdot 35+(5-3))=121+37=\boxed{158}$

與你結論一致：**Column-major，m=35，Loc=158**。

---

## 4)三維陣列位址

---

- **第一維 (i)** → 書的「頁數 (plane)」
- **第二維 (j)** → 每一頁的「行 (row)」
- **第三維 (k)** → 每一行中的「字 (column)」

當我們要找元素 `A[i, j, k]`，就像是：

> 「先翻到第 i 頁 → 找到第 j 行 → 再找到第 k 個字。」
> 

---

## 🧮 基本定義

假設陣列：

$[A[L_1:U_1,, L_2:U_2,, L_3:U_3]]$

| 符號 | 意義 |
| --- | --- |
| **Base(A)** | 陣列首元素 `A[L₁, L₂, L₃]` 的起始位址 |
| **w** | 每個元素的大小（bytes） |
| **Lᵢ, Uᵢ** | 第 i 維的下界與上界 |
| **Dᵢ = Uᵢ − Lᵢ + 1** | 第 i 維的長度 |

---

## 1️⃣ 列為主序 (Row-Major Order)

在 **Row-Major** 中，**最後一個索引 (k)** 變化最快。

也就是說，記憶體中會**先放完一整列 (row)**，再換下一列、下一頁。

👉 C、C++、Java、Python (NumPy) 全都採用這種方式。

🧭 **比喻：**

> 像在查字典：
> 
> 
> 先翻到「第 i 頁」→ 在頁面上往下找到「第 j 行」→ 向右找「第 k 個字」。
> 

**公式：**

$[\boxed{\text{Address}(A[i,j,k])= \text{Base}(A)w \times [ (i - L_1),D_2,D_3 + (j - L_2),D_3 + (k - L_3) ]}]$

**解釋：**

| 部分 | 代表意義 |
| --- | --- |
| $(i - L_1),D_2,D_3$ | 前面有多少「整頁」元素 |
| $(j - L_2),D_3$ | 同頁內，前面有多少「整列」元素 |
| $(k - L_3)$ | 同列內，前面有多少元素 |

---

## 2️⃣ 行為主序 (Column-Major Order)

在 **Column-Major** 中，**第一個索引 (i)** 變化最快。

這表示記憶體會**先放完一整行 (column)**，再換下一行、下一塊。

👉 用於 **FORTRAN、MATLAB、R** 等語言。

🧭 **比喻：**

> 像在查表格資料：
> 
> 
> 先看「第 k 塊資料區」→ 找到「第 j 欄」→ 讀出「第 i 行」的值。
> 

**公式：**

$[\boxed{\text{Address}(A[i,j,k])= \text{Base}(A)w \times [ (k - L_3),D_1,D_2 + (j - L_2),D_1 + (i - L_1) ]}]$

**解釋：**

| 部分 | 代表意義 |
| --- | --- |
| $(k - L_3),D_1,D_2$ | 前面有多少「整塊」元素 |
| $(j - L_2),D_1$ | 同塊內，前面有多少「整行」元素 |
| $(i - L_1)$ | 同行內，前面有多少元素 |

---

# 三、上/下三角矩陣（含對稱矩陣）— 壓縮儲存公式

以 $n\times n$、0-based 索引（i,j ∈ [0..n-1]），包含主對角。只存三角區到**一維陣列 T**（元素大小 dd 省略）：

## 1) Lower Triangular（含對角，i ≥ j）

- **Row-major 線性索引**

$\boxed{\ \text{idx}_L(i,j)=\frac{i(i+1)}{2}+j\quad (i\ge j)\ }$

- 元素數 $n(n+1)/2$

## 2) Upper Triangular（含對角，i ≤ j）

- **Row-major 線性索引**

 $\sum_{r=0}^{i-1}(n-r)\ +\ (j-i)
=ni-\frac{i(i-1)}{2}+(j-i)
= \boxed{\ ni-\frac{i(i+1)}{2}+j\quad (i\le j)\ }$

> Column-major 版本把「行、列角色」對調即可推得；對稱矩陣（Symmetric）通常只存上或下三角並在取用時鏡射。
> 

---

# 四、稀疏矩陣（Sparse Matrix）

## 1) 什麼時候用？

- 非零元素個數 **nnz ≪ mn**；節省空間/加速運算與快取。

## 2) 常見儲存格式

### (a) COO（三元組）

- 陣列 `row[nnz], col[nnz], val[nnz]`（次序任意或按(row,col)排序）
- 易於**逐筆插入/組裝**，適合建表；運算前常轉 CSR/CSC。

### (b) CSR（Compressed Sparse Row）

- `val[nnz]`：非零值
- `col_idx[nnz]`：對應的列索引
- `row_ptr[m+1]`：第 i 行的非零在 `[row_ptr[i], row_ptr[i+1])`
- **優點**：快速取「一整行」、SpMV（y = A x）快；Row-major 思維友好。

### (c) CSC（Compressed Sparse Column）

- 與 CSR 對偶，用 `col_ptr[n+1]`，快取「一整列」、有利於**解轉置系統**或**列操作**。

## 3) 典型操作複雜度（CSR）

- 取第 i 行：$O(\text{row\_nnz})$
- SpMV：$O(\text{nnz})$
- 加法/乘法：依圖樣（pattern）合併，常見為 $O(nnz+)O(\text{nnz}+)$ 級別

---

# 五、樞紐矩陣（Permutation / Pivot Matrix）

## 1) 定義與性質

- **Permutation Matrix**：將單位矩陣 II 的行或列做一個置換得到的 0/1 矩陣。
- **性質**：$P^{-1}=P^{\mathsf T}$（正交），行（或列）互為 one-hot，$\det(P)=\pm1$。

## 2) 用途

- **高斯消去/ LU 分解**的樞紐選擇（Pivoting）：
    - **部分樞紐（row pivoting）**：P A = L U
    - **完全樞紐（row+col）**：P A Q = L U
- **重排序**：改善稀疏矩陣填充（fill-in）、提升數值穩定性或快取局部性（如 RCM、AMD 等）。

## 3) 快速表達

- 實作中很少真的存 PP 為矩陣，多用**整數置換向量** `p[]` 代表行/列的對應關係：
    - 行換位：`A ← A[p, :]`
    - 列換位：`A ← A[:, q]`

---

# 六、實務小抄

- **掃描順序**要配合儲存順序：Row-major 以行為主（連續），Column-major 以列為主；可減少 cache miss。
- **位址推導**一定記得**下界校正**：(i−rL)(i-r_L)、(j−cL)(j-c_L)。
- **三角/對稱矩陣**可省一半空間；索引公式（上/下三角）要熟。
- **稀疏格式選擇**：建表用 **COO**，乘法/行訪問用 **CSR**，列訪問/求解 ATA^{\mathsf T} 用 **CSC**。
- **樞紐**只要記 permutation 向量即可；數值法常見 **PA=LU**。
    
    ---
    

```jsx
Address(i) = loc(A) + index × Sizeof(ElemenType)
```

- `i**ndex**`：元素的索引值（從 0 開始）
- `Sizeof(ElemenType)`：每個元素所佔的位元組（Byte）
- `loc(A)` ：陣列起始元素的記憶體位址（即 A[0] 的地址）
    
    ---