# Hash Table

上次編輯時間: 2025年10月8日 下午6:04
建立時間: 2025年8月29日 下午4:32

# 散列表（Hash Table）

**核心想法**

用散列函數 `h(key)` 把「關鍵字(key) → 儲存位址(value)（桶/槽）」直接映射。理想查找、插入均 **O(1)**；最壞因衝突可退化到 **O(n)**。

**名詞**

- **散列函數**：`h(key) → [0, m-1]`（m = 表格長度）。
- **衝突/碰撞**：不同鍵映到同一位址。
- **同義詞**：在同一 `h(·)` 下映到同位址的不同鍵。
- **裝載因子** `α = n / m`：元素數 / 槽數；越大衝突越多。

---

## 基本操作

- **查找**：算位址 → 槽內找（或沿探查序列找）。平均 O(1)。
- **插入**：算位址 → 空就放；否則按所選**衝突解法**處理。
- **刪除**：
    - 拉鍊法：鏈上刪節點即可。
    - 開放定址：用 **墓碑標記**（tombstone），避免斷探查鏈。

---

## 設計原則（四要素）

- **定義域**要涵蓋所有可能鍵（別讓鍵算不出值）。
- **值域**必須落在表長 `[0 … m-1]`。
- **均勻性**：輸出盡量平均分布，降低碰撞。
- **簡單快**：計算成本低（別用階乘、巨額計算）。

> 口訣：域要全、值要界、分布勻、算得快。
> 

---

## 四種常見構造法

### 1) 除留餘數法（最常考也最常用）

- 形式：`h(k) = k mod P`，**P 取 ≤ 表長 m 的最大質數**（或接近 m 的質數）。
- 為何用質數？合數會與很多鍵有**公因數**→ 餘數落在少數槽，分布不勻；質數能顯著改善均勻性。
- 例：`m=15` 仍建議 `P=13`，而非 15。

### 2) 直接定址法（鍵近似連續）

- 形式：`h(k) = a·k + b` 或 `h(k) = k - k_min`。
- 優點：**無碰撞**（鍵連續時）。
- 風險：鍵**稀疏/缺號**會造成大量空槽→ 浪費空間。
- 例：學號連號 30 人，映到 `0..29`。

### 3) 數字分析法（鍵集合已知）

- 觀察各**數碼位**的分布，**取分布最均勻**的位數做位址。
- 例：手機號末 4 碼較均勻 → 直接做位址（表長 1 萬）。

### 4) 平方取中法（各位都不均勻時）

- 步驟：先算 `k^2`，**取中間的 r 位**作位址（`r ≈ ⌈log10 m⌉`）。
- 直覺：中間位受到每一數碼位的「進位/疊加」影響，分布更均勻。
- 用於：各位分布都怪、又沒有明顯可選位時。

## 衝突處理兩大派

### 1) 拉鍊法（Separate Chaining）

每個槽存一條鏈（或動態陣列/樹）。

- **優點**：實作簡單；擴表前不易塞爆；刪除容易。
- **代價**：鏈上搜尋要 O(鏈長)；需指標/額外空間。
- **期望成本**：平均查找/插入 ≈ **O(1 + α)**。
    
    ![image.png](assets/image%2083.png)
    

### 2) 開放定址（Open Addressing）

發生衝突就**在表內找下一個空槽**。常見探查：

- **線性探查**：`i, i+1, i+2, …`（易「主聚集」）。
    
    ![image.png](assets/image%2084.png)
    

- **平方探查/二次探測法**：`i, i±1^2, i±2^2, …`（減輕聚集，m 常取 2 的冪）。
    
    ![image.png](assets/image%2085.png)
    
- **雙重雜湊**：`i + j * g(key)`（j=0,1,2…；聚集最少，函數要互質）。
- **建議**：保持 `α ≲ 0.7`，否則效能急降。
- **期望成本（均勻散列假設）**：
    
    成功 ≈ `(1/2) * (1 + 1/(1-α))`；失敗 ≈ `1/(1-α)`。
    

---

## 1) ASL（平均查找长度）怎么**手算**

**线性探测统一公式**：`h_i(k) = (h(k) + i) mod m`，逐格探测直到命中或遇到首个“从未用过的空槽”。

### A. 查找**成功** ASL

- 对象：表内已存在的每个元素。
- 计数：该元素被找到前比较的次数（= 插入它时发生的探测次数）。
- 等概率：若表内有 `n` 个元素，ASL_succ = `(c1 + c2 + … + cn) / n`。
- 小技巧：**“插入时的探测次数 = 成功查找的比较次数”**，直接复用插入过程的步数即可。
- 视频示例结果：ASL_succ = **2.5**。
    
    ![image.png](assets/image%2086.png)
    

### B. 查找**失败** ASL

- 对象：**散列函数初址的可能取值个数** `R`（不是表长 `m`！）。
- 计数：从某个初址出发，按线性探测比较到**第一个真正空槽（未使用过）**所用的次数；**逻辑删除位（tombstone）不算空**，必须继续探测。
- 等概率：ASL_fail = `(c0 + c1 + … + c_{R-1}) / R`。
- 视频示例结果：ASL_fail = **7**。

### C. 删除带来的影响（重点）

- **只能逻辑删除**（做墓碑标记），不可物理清空；否则会“断链”导致后续查找误判失败。
- 计算 ASL 时：
    - 成功：仍按探测序列走过墓碑位，计入比较次数。
    - 失败：墓碑位按“占用”处理，必须继续探测到**首个从未使用的空槽**。
    
    ![image.png](assets/image%2087.png)
    

### 常见坑

- ❌ 把分母写成表长 `m`：**失败 ASL 的等概率应按 `R`（散列函数取值范围）平均**。
- ❌ 把逻辑删除当成空槽：失败计数会被低估。

---

## 2) 装填因子 α

- 定义：`α = n / m`（记录数 / 表长），反映“有多满”。
- 越大 ⇒ 冲突越多 ⇒ 插入、查找步数变长 ⇒ **ASL 变大**。
- 实务：α 过大或墓碑过多时需 **rehash/整理**。

---

## 3) 聚集（堆积）现象

- 含义：**多个不同初址的元素争同一段后继位置**（线性探测最明显，易形成长连续块）。
- 影响：连续块里失败查找要比到**第一个空槽**才停，比较次数大。
- 缓解：换**二次/平方探测、双散列、伪随机序列**；合理选表长（常取质数），能打散探测路径、减轻聚集。

---

## 4) 选学：均匀散列假设下的近似期望（线性探测）

- 成功：`E[探测] ≈ (1 + 1/(1-α)) / 2`
- 失败：`E[探测] ≈ (1 + 1/(1-α)^2) / 2`

> 用于快速估算整体趋势；考试给具体表时仍按逐项计数方法算。
> 

---

## 5) 考场“秒做”模板

1. 先画（或心算）**最终表形态**，标清空槽与墓碑。
2. **成功 ASL**：对每个已存元素取其插入/查找步数求均值。
3. **失败 ASL**：枚举 `R` 个初址，数到首个“真空槽”的比较次数求均值。
4. 自查两点：是否把墓碑当空？是否把分母错用成 `m`？

# 觀念總結&錯誤題回顧

装填因子 α

- 定义：`α = n / m`（记录数 / 表长），反映“有多满”。

ASL 依賴於 α 不直接依賴於 n,m

### ASL 成功

分母是n

### ASL 失敗常见坑

- ❌ 把分母写成表长 `m`：**失败 ASL 的等概率应按 `R`（散列函数取值范围）平均**。
- ❌ 把逻辑删除当成空槽：失败计数会被低估。