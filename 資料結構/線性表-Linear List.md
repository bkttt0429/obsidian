# ç·šæ€§è¡¨-Linear List

ä¸Šæ¬¡ç·¨è¼¯æ™‚é–“: 2025å¹´9æœˆ22æ—¥ ä¸‹åˆ6:36
å»ºç«‹æ™‚é–“: 2025å¹´6æœˆ24æ—¥ ä¸‹åˆ2:31

# ç·šæ€§è¡¨

**ç·šæ€§è¡¨**æ˜¯ä¸€ç¨®**æœ‰åºï¼Œæœ‰é™ä¸”ç›¸åŒæ•¸æ“šé¡å‹**çš„è³‡æ–™é›†åˆ

- é™¤äº†ç¬¬ä¸€å€‹å…ƒç´ ï¼Œ**æ¯å€‹å…ƒç´ æœ‰ä¸”åªæœ‰ä¸€å€‹å‰é©…**ï¼›
- é™¤äº†æœ€å¾Œä¸€å€‹å…ƒç´ ï¼Œ**æ¯å€‹å…ƒç´ æœ‰ä¸”åªæœ‰ä¸€å€‹å¾Œç¹¼**ã€‚

---

# ç·šæ€§è¡¨å¸¸è¦‹çš„åˆ†é¡

1. **é †åºè¡¨ï¼ˆArray Listï¼‰**
2. **éˆå¼å­˜å„²**
    1. **å–®å‘éˆçµä¸²åˆ—ï¼ˆSingly Linked Listï¼‰**
    2. **é›™å‘éˆçµä¸²åˆ—ï¼ˆDoubly Linked Listï¼‰**
    3. **å¾ªç’°éˆçµä¸²åˆ—ï¼ˆCircular Listï¼‰**

---

## **é †åºè¡¨ï¼ˆArray Listï¼‰**

é †åºè¡¨æ˜¯ä¸€ç¨®ä½¿ç”¨**é™£åˆ—**ä¾†å„²å­˜è³‡æ–™çš„ç·šæ€§çµæ§‹ã€‚å…ƒç´ åœ¨è¨˜æ†¶é«”ä¸­**ç”¨ä¸€å¡Šé€£çºŒè¨˜æ†¶é«”å„²å­˜è³‡æ–™**ï¼Œå¯é€éç´¢å¼•ï¼ˆindexï¼‰å¿«é€Ÿå­˜å–`O(1)`ã€‚

### [è¨˜æ†¶é«”ä½ç½®è¨ˆç®—](è¨˜æ†¶é«”åœ°å€è¨ˆç®—.md)

---

### å¯¦ä½œ(**Implementation**)

**çµæ§‹å®šç¾©**

```csharp
#define MaxSize 10
typedef struct {
    ElemType data[MaxSize]; // ä½¿ç”¨å›ºå®šå¤§å°çš„é™£åˆ—
    int length;             // å¯¦éš›ä½¿ç”¨çš„é•·åº¦
} SqList;
```

**ä¸€ã€åˆå§‹åŒ–**

**âœ… éœæ…‹åˆ†é…ï¼ˆStatic Allocationï¼‰**

```csharp

// åˆå§‹åŒ–ï¼šè¨­é•·åº¦ç‚º 0ï¼Œé¿å…è®€åˆ°é«’æ•¸æ“š
void InitList(SqList *L) {
    L->length = 0;
}

int main() {
    SqList L;
    InitList(&L);
}

```

ğŸ“Œ å„ªé»ï¼š

- ä¸éœ€ä½¿ç”¨ `malloc`ï¼Œç°¡å–®å¿«é€Ÿï¼Œä¸ç”¨æ‰‹å‹•é‡‹æ”¾è¨˜æ†¶é«”ï¼Œè¨˜æ†¶é«”ç®¡ç†è¼ƒå®‰å…¨ã€‚

âš ï¸ ç¼ºé»ï¼š

- å®¹é‡å›ºå®šï¼Œç„¡æ³•æ ¹æ“šéœ€æ±‚è‡ªå‹•æ“´å±•ã€‚
- è³‡æ–™å€ `data[]` ç„¡æ³•åœ¨åŸ·è¡ŒæœŸé–“æ›´æ›å¤§å°ã€‚

**âœ… å‹•æ…‹åˆ†é…ï¼ˆDynamic Allocationï¼‰**

```c
L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);
```

```csharp
#include <stdlib.h>
#define InitSize 10 //é»˜èªæœ€å¤§é•·åº¦
typedef struct{
		int *data; //å‹•æ…‹åˆ†é…çš„æŒ‡é‡
		int MaxSize;    //æœ€å¤§å®¹é‡
		int lenght;     //ç•¶å‰é•·åº¦
}SqList;
// åˆå§‹åŒ–ï¼šé…ç½®è¨˜æ†¶é«”ä¸¦åˆå§‹åŒ–å±¬æ€§
void InitList(SeqList &L){
		L.data=(int*)malloc(InitSize*sizeof(int));
		L.lenght=0;
		L.MaxSize=InitSize;
}
int main(){
		SeqList L;
		InitList (L);
}
```

**ğŸ“Œ å„ªé»ï¼š**

- ç©ºé–“å¯å‹•æ…‹é…ç½®ï¼Œæ“´å±•æ€§ä½³ã€‚
- å¯ä¾æ“šå¯¦éš›éœ€æ±‚å¢é•·ï¼ˆæ­é… `realloc` å¯å¯¦ç¾å¢å®¹ï¼‰ã€‚

**âš ï¸ ç¼ºé»ï¼š**

- éœ€æ‰‹å‹•é‡‹æ”¾è¨˜æ†¶é«”ï¼ˆç”¨ `free(L.data)`ï¼‰ï¼Œå¦å‰‡æœƒç”¢ç”Ÿè¨˜æ†¶é«”æ´©æ¼ã€‚

<aside>
ğŸ’¡

**ğŸ“š å»¶ä¼¸çŸ¥è­˜**

**ğŸ”§ ä¸€ã€å‹•æ…‹å¢å®¹ç­–ç•¥**

è‹¥æ’å…¥å…ƒç´ æ™‚ç©ºé–“ä¸è¶³ï¼Œå¯é€²è¡Œ **å‹•æ…‹æ“´å®¹**ï¼ˆå¸¸è¦‹ç­–ç•¥ç‚ºã€Œå€å¢æ³•ã€ï¼‰ï¼š

```c
c
void IncreaseSize(SqList *L, int increment) {
    L->data = (int*)realloc(L->data, (L->MaxSize + increment) * sizeof(int));
    L->MaxSize += increment;
}
```

---

**ğŸ“ äºŒã€æŒ‡æ¨™é¡å‹èˆ‡ä½ç§»å–®ä½**
åœ¨ C/C++ ä¸­ï¼Œ**æŒ‡æ¨™çš„åŠ æ¸›é‹ç®—æœƒæ ¹æ“šå…¶é¡å‹è‡ªå‹•æ›ç®—ä½ç§»è·é›¢**ã€‚

```csharp
int *data;         // æ¯æ¬¡ data + 1ï¼Œå¯¦éš›ç§»å‹• 4 bytesï¼ˆå‡è¨­ int ç‚º 4 bytesï¼‰
ElemType *data;    // æ¯æ¬¡ data + 1ï¼Œç§»å‹• sizeof(ElemType) bytes
```

</aside>

---

**äºŒã€æ’å…¥æ“ä½œ**

Concept:

![**ã€‚å°‡ i å…ƒç´ åŠä¹‹å¾Œå…¨éƒ¨å¾Œç§»**](assets/image.png)

**ã€‚å°‡ i å…ƒç´ åŠä¹‹å¾Œå…¨éƒ¨å¾Œç§»**

**æ™‚é–“è¤‡é›œåº¦åˆ†æ**

$$
\frac{0 + 1 + 2 + \cdots + (n - 1)}{n} =\frac{n-1}{2} 
$$

`O(n)`

```csharp
/**
 * @param L ç·šæ€§è¡¨çš„åƒè€ƒ
 * @param i æ’å…¥ä½ç½®ï¼ˆ1 â‰¤ i â‰¤ length + 1ï¼‰
 * @param e è¦æ’å…¥çš„å…ƒç´ 
 */
bool listInsert(SqList &L, int i, int e) {
    // è‹¥ç©ºé–“å·²æ»¿ï¼Œç„¡æ³•æ’å…¥
    if (L.length >= MaxSize)
        return false;
    // æª¢æŸ¥æ’å…¥ä½ç½®æ˜¯å¦åˆæ³•ï¼ˆä½ç½®å¾ 1 åˆ° length + 1ï¼‰
    if (i < 1 || i > L.length + 1)
        return false;
    // å¾æœ€å¾Œä¸€å€‹å…ƒç´ é–‹å§‹ï¼Œé€å€‹å‘å¾Œæ¬ç§»ï¼Œç‚ºæ’å…¥ä½ç½®é¨°å‡ºç©ºé–“
    for (int j = L-.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
 
    L.data[i - 1] = e;// æ’å…¥å…ƒç´  e
    L.length++;// é•·åº¦åŠ  1
    return true;
}
```

---

**äºŒã€åˆªé™¤æ“ä½œ**

**æ™‚é–“è¤‡é›œåº¦åˆ†æ**

$\frac{(n-1) + (n-2) + \cdots + 0}{n} =  \frac{n-1}{2}$

`O(n)`

```csharp
bool listDelete(SqList &L, int i, int &e) {
    // åˆ¤æ–·ä½ç½®æ˜¯å¦åˆæ³•ï¼ˆ1-basedï¼‰
    if (i < 1 || i > L.length)
        return false;
    // å„²å­˜æ¬²åˆªé™¤çš„å…ƒç´ 
    e = L.data[i - 1];
    // å°‡å¾ŒçºŒå…ƒç´ å‘å‰æ¬ç§»
    for (int j = i; j < L.length; j++) {
        L.data[j - 1] = L.data[j];
    }
    // é•·åº¦æ¸› 1
    L.length--;
    return true;
}
```

---

**ä¸‰ã€æŸ¥æ‰¾**

**æ™‚é–“è¤‡é›œåº¦åˆ†æ**

`O(n)`

```csharp
/**
 * åœ¨é †åºè¡¨ L ä¸­æŸ¥æ‰¾å…ƒç´  eï¼Œå›å‚³å…¶é¦–æ¬¡å‡ºç¾çš„ä½ç½®ï¼ˆ1-basedï¼‰
 * è‹¥æ‰¾ä¸åˆ°ï¼Œå›å‚³ 0
 */
int LocateElem(const SqList &L, int e) {
    for (int i = 0; i < L.length; i++) {
        if (L.data[i] == e)
            return i + 1; // å›å‚³é‚è¼¯ä½ç½®ï¼ˆ1-basedï¼‰
    }
    return 0;
}
```

<aside>
ğŸ’¡

**å‚³å€¼ï¼ˆby valueï¼‰** vs **å‚³åƒè€ƒï¼ˆby referenceï¼‰**ã€‚

| å¯«æ³• | å«ç¾© | æ˜¯å¦ä¿®æ”¹åˆ°åŸå§‹è³‡æ–™ | æ•ˆç‡ |
| --- | --- | --- | --- |
| `SqList L` | å‚³å€¼ï¼šè¤‡è£½ä¸€ä»½ L çµ¦å‡½å¼ | âŒ ä¸æœƒ | è¼ƒä½ï¼ˆå› ç‚ºæœƒè¤‡è£½ï¼Œç•¶é™£åˆ—å¾ˆå¤§ï¼‰ |
| `SqList &L` | å‚³åƒè€ƒï¼šå‚³åŸå§‹ L æœ¬äºº | âœ… æœƒ | âœ… è¼ƒé«˜æ•ˆç‡ |
| `const SqList &L` | å‚³å”¯è®€åƒè€ƒï¼ˆå®‰å…¨ä¸”é«˜æ•ˆï¼‰ | âŒ ä¸æœƒ | âœ… âœ…ï¼ˆæœ€ä½³å¯«æ³•ï¼‰ |
</aside>

## [**éˆå¼å­˜å„²**](éˆå¼å­˜å„².md)