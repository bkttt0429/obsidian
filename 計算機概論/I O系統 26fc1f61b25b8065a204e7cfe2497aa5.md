# I/O系統

上次編輯時間: 2025年9月17日 下午7:56
建立時間: 2025年9月15日 下午6:27

## I/O 系統基本概念

# I/O 系统概念 & 组成

- **I/O 设备（外设）**
    - 输入：键盘、鼠标；输出：显示器、打印机；既输又出：磁盘/光盘（常单列为**外存**）。
- **I/O 接口 = I/O 控制器 = 设备控制器（在主板/南桥等芯片里）**
- 典型寄存器：
    - **数据寄存器（DR）**：设备↔主机的实际数据。
    - **控制寄存器（CR）**：主机写入“让设备干什么”的控制信息。
    - **状态寄存器（SR）**：设备忙/就绪/故障/结束等标志位。

![image.png](assets/image%2051.png)

- **I/O 软件（操作系统侧）**：驱动程序 + 管理程序等（OS 课重点，这里记“驱动把通用命令翻译成设备可识别的命令码”即可）。
- **I/O 指令 vs 通道指令**
    - **I/O 指令**：给 CPU 执行，格式含**操作码 + 命令码 + 设备码**（命令码说“设备该干啥”）。
    - **通道指令**：给**通道**执行，组成“**通道程序**”，通道像“弱化 CPU”专管 I/O。

---

# 四种 I/O 控制方式（由低到高）

> 关键词：CPU参与频度 / 硬件复杂度 / 吞吐量 / 适用设备
> 

## 1) 程序查询（Polling）

流程：CPU 发 I/O 指令 → **反复读 SR 轮询** → 就绪后从 DR 取/写数据 → 继续程序。

特点：实现最简单；**CPU 忙等**、利用率低；适合**极慢、极少量**的 I/O（如偶发键盘输入）。

## 2) 程序中断（Interrupt-Driven）

流程：CPU 发 I/O 指令→去干别的→**设备就绪发中断**→CPU 进 ISR 读/写 DR→返回。

特点：**解除盲等**；**每个字/小块就可能一次中断**，中断率高会拖慢 CPU；适合**中低速/零散** I/O（键盘、串口等）。

## 3) DMA（Direct Memory Access，直接存储器访问）

结构：主存 ↔ **DMA 控制器** ↔ 高速外设（如磁盘）。

流程（以读盘为例）：

1. CPU 仅一次编程 DMA：方向、**主存起址**、**外设地址/块号**、**传输字数**；
2. DMA 与外设分批搬运，**每字“偷取”一个主存存取周期**（CPU短暂让路）；
3. **整块完成才中断 CPU 一次**（告知“已完成/异常”）。
    
    特点：CPU 负担小、吞吐高；对主存有**总线/存取周期仲裁**（cycle stealing/burst）；适合**高速块设备**。
    

![image.png](assets/image%2052.png)

## 4) 通道（Channel）

![image.png](assets/image%2053.png)

- **通道 = 专用“微处理器”** 负责 I/O：执行**通道程序**，可管理**多设备、多步骤**（排队、分发、按序搬运……）。
- CPU 只：下达“**哪台设备 + 通道程序地址**”；**一大批 I/O 活动完成后**才被中断一次。
- 用途：**中大型机/高端服务器**，海量外设（成百上千磁盘）场景，**进一步把 CPU 从 I/O 管理中解放**。

---

# 数据流区别（面试&大题爱考）

- **查询/中断**：设备→I/O 控制器 DR → **CPU 寄存器** → 主存（CPU做“中转”*每字/次）。
- **DMA**：设备→DMA→**主存 直达**（CPU仅首/末参与）。
- **通道**：设备群↔通道↔主存（CPU几乎不插手，通道自己跑“通道程序”）。

---

# 结合示例（`scanf("%c",&i);` 键盘输入）

- 查询：CPU 反复查 SR，等就绪取 DR，再写主存[i]。
- 中断：键盘就绪→中断→ISR 取 DR→写主存[i]。
- 换成磁盘等**高速设备**：中断会**太频繁** → 用 **DMA**（整块完成才中断一次）。
- 海量设备并行：用**通道**（通道程序批量管控）。

---

# 硬核对比表（背这个就够）

| 方式 | CPU参与 | 中断频度 | 硬件复杂 | 吞吐 | 典型设备 |
| --- | --- | --- | --- | --- | --- |
| 查询 | 每字都忙等 | 无 | 低 | 低 | 键盘极慢 I/O |
| 中断 | 每字/小块进 ISR | 高 | 低~中 | 中 | 串口、低速设备 |
| DMA | 首末一次 | 低（每块1次） | 中 | 高 | 磁盘、网卡等块/高速 |
| 通道 | 批处理完成一次 | 很低 | 高 | 最高 | 大型机海量外设 |

---

# 易错/必考点

- **“DMA 每传一字都中断”** ❌：**整块**结束才中断一次。（也是一字一字傳但是先存在DMA暫存裡）
- **“DMA 不占用主存周期”** ❌：会**抢占/轮流**主存周期（cycle stealing），CPU短暂等待。
- **“通道=DMA”** ❌：通道能跑**通道程序**，可管多设备/多步骤，层次更高。
- **I/O 指令格式**要点：有**命令码**（给设备用），区别于普通算术/访存指令。
- **I/O 接口三寄存器**：DR/CR/SR 的用途要一一对得上。
- 与总线章节呼应：DMA/通道都涉及**总线仲裁**；DMA 常配**DMA 总线/存储总线**，高效块传。

---

# 两句总结

- 从 **查询→中断→DMA→通道**，**CPU参与越来越少，系统吞吐越来越高**。
- 记住：**慢设备用中断，快设备用 DMA，超多设备上通道**；配套背下 **DR/CR/SR** 与 **I/O/通道指令**区别。

## 外部設備

# VRAM（显存）——一定会考的两件事

## 1) 一帧所需显存容量（理论最小）

公式：

**FrameSize = 分辨率像素数 × 每像素位数(bpp) ÷ 8（字节）**

- 黑白/灰度：bpp = 灰度位数（例如 8bpp = 256 级灰度）
- 彩色常见：24bpp（RGB各8位）、**更常见实际存储是 32bpp（RGBA/对齐）**

👉 若使用**双缓冲/三缓冲**，帧缓冲至少**×2/×3**。

- *例1（文中配置）：**1440×900，24bpp

像素数 = 1,296,000

FrameSize = 1,296,000 × 24 ÷ 8 = **3,888,000 B ≈ 3.71 MiB（≈3.89 MB）**

## 2) 显存带宽（写入速率下限）

公式：

**VRAM 带宽 ≥ FrameSize × 刷新率（Hz）**

**例2（延续例1，60Hz）：**

带宽 ≥ 3,888,000 × 60 = **233,280,000 B/s**

≈ **222.6 MiB/s**（二进制） ≈ **233.3 MB/s**（十进制）

> 注：考试更看重你是否会“像素数 × bpp/8 × 刷新率”，单位写清楚“字节/秒”。是否考虑 24/32bpp、双缓冲，看题意（题上若写明“帧缓冲×2/×3”或给出像素格式，就照做）。
> 

---

# 显示器关键指标（30 秒速记）

- **屏幕尺寸**：对角线英寸（与长宽比无关）。
- **分辨率**：横×纵像素数（像素总数=两者相乘）。
- **灰度级**：n 位可表示 **2ⁿ** 种灰度/颜色深度。
- **刷新率**：每秒刷新的帧数（60/120 Hz…），太低会可见闪烁（<≈30Hz）。

---

# 字符显示器的原理（第二个常考点）

> 关键词：显存里存“码”，字形在 ROM，最后变成点阵亮灭
> 
1. **显存（字符模式）里存的是字符编码**：英文常为 **ASCII 码**（汉字可为机内码）。
2. **字符发生器（ROM）**：内置每个字符的**点阵字形码**（例如 8×16 点阵 → 每字符 128 位）。
3. **控制/扫描电路**：按行列读出该字符的点阵位，驱动显示器相应像素**亮/灭**。
4. **输出**：CRT/LCD/LED 的扫描与发光机制不同，但**本质都是把“字形点阵”映射到像素**。

> 对比：
> 
> - **字符显示器**：显存放“**字符码**”，由 **字符发生器 ROM** 转为点阵再显示。
> - **图形/图像显示器**：显存直接放“**像素点阵**”（帧缓冲），无需字符发生器。

**小题常见**：给出“字形点阵 m×n”，问每字符需要多少位/字节；或给一屏字符行×列，算显存最小容量（若有**属性字节**如颜色/闪烁，还要**再加**）。

---

# 其它外设要点（知道就行）

- **键盘**：按键闭合→编码→（多为 ASCII/扫描码）→ 通过 I/O 接口送主机。
- **鼠标**：机械式（滚球+编码盘）/光电式（光学传感器）；上报位移与按键。
- **显示器类型**：
    - **CRT**（老式显像管，电子束+荧光屏）；
    - **LCD**（液晶）/**LED**（发光二极管/OLED 等），现代主流。
- **图形 vs 图像**：图形强调矢量/规则形（工程/波形/行情专显），图像是我们日常屏幕的位图帧缓冲。

---

# 易错点 & 提醒

- **单位**：容量用 **字节（B）**；带宽用 **B/s**（注意 b 与 B）。
- **24bpp vs 32bpp**：很多实现用 32bpp（多 8 位用于 Alpha/对齐），题目未指明就按题干。
- **双/三缓冲**：若题目强调“帧缓冲×2/×3”，别忘了乘。
- **字符模式显存**≠“像素帧缓冲”**：前者存编码，字形在 ROM；后者直接存像素。
- **刷新率**影响的是**带宽**（帧/秒 × 帧大小），不是单帧容量。

---

# 快速练习（再巩固一下）

1. **1920×1080，32bpp，60Hz，双缓冲**
    - 单帧：2,073,600 × 4 = **8,294,400 B ≈ 7.91 MiB**
    - 双缓冲容量≥ **≈15.82 MiB**
    - 带宽≥ **8,294,400 × 60 ≈ 497.7 MB/s（≈474.9 MiB/s）**
2. **字符模式：80×25 字符，字节/字符=1（ASCII），属性字节=1**
    - 显存≥ 80×25×(1+1) = **4,000 B ≈ 3.91 KiB**

## I/O接口

# 一、I/O 接口（控制器）到底干啥

1. **数据缓冲**：用数据缓冲寄存器（Data Buffer）“撮合”快的主机和慢的外设。
2. **状态监测**：维护**状态寄存器**（忙/就绪/出错/完成…）。
3. **控制与定时**：接收 CPU 的**命令字**（Control/Command），产生对外设的控制信号，配合同步/异步时序。
4. **串/并转换**：设备侧多为**串行**，主机侧常见并行（注意：**现代也可能串行**）。
5. **通信/中断**：能向 CPU 发**中断请求**，并可携带**中断类型号**（配合状态字）。

# 二、接口内部结构与“合二为一”的由来

- 典型寄存器：**数据缓冲寄存器**、**状态寄存器**、**控制（命令）寄存器**。
- 很多实现把**状态/控制**做成**同一物理寄存器**：
    - 原因：**先写命令**→控制逻辑取走后该寄存器空闲；设备工作期间需要**回写状态**。时间上**错开复用**。
- 其他常见逻辑：地址译码、控制/定时、中断控制、串并转换、设备选择。

# 三、工作流程（以“向打印机输出”举例）

1. CPU **写控制寄存器**：下发**命令字**（如启动打印、模式等）。
2. 接口控制逻辑对设备发控制信号；CPU **轮询状态**或等待**中断**。
3. CPU **写数据缓冲寄存器**（要打印的数据）。
4. 设备消化数据；完成后接口更新**状态位**，并可能向 CPU 发**中断**（类型号通过数据总线/状态字给出）。

> 端口的读写权限常见：数据端口 可读/可写；状态端口 只读；控制端口 只写（题目如有特例以题干为准）。
> 

# 四、I/O 端口 = 接口里的可寻址寄存器

- 数据端口 / 状态端口 / 控制端口 —— 都是“**端口**”。
- CPU 访问端口需要：**地址线**（指明是哪一个端口/哪一组设备）、**控制线**（读/写、中断请求）、**数据线**（数据、命令字、状态字、甚至中断类型号）。

> 多设备怎么选？两路思路：
> 
> 
> (A) 给**每个设备**配一组端口（数据/状态/控制） → 通过访问不同端口组区分设备；
> 
> (B) 地址里既含**设备号**又含**寄存器号**（分时/分段地传）。
> 

# 五、端口编址：统一编址（MMIO）vs 独立编址（Port I/O）

![image.png](assets/image%2054.png)

| 维度 | **统一编址（Memory-Mapped I/O）** | **独立编址（Isolated I/O）** |
| --- | --- | --- |
| 地址空间 | 端口与内存**共用**同一地址空间 | 端口与内存**各自**有空间 |
| 指令支持 | **任意访存指令**都可访问端口（load/store/算术对端口生效） | 只能用**专门 I/O 指令**（如 x86：IN/OUT、INS/OUTS） |
| 编程灵活性 | **高**（可对端口做加、移位等操作） | **低**（指令少，读写为主） |
| 地址译码 | 地址位**多**→译码**慢**一些 | 地址位**少**→译码**快**、逻辑更简单 |
| 对内存空间影响 | **占用**内存地址空间 | **不占用**内存地址空间 |
| 硬件控制信号 | 与存储器读写**共用** | 需**额外 I/O 读写信号**（控制逻辑更复杂） |
| 常见在哪 | RISC/嵌入式常见；现代通用平台也广用 | 传统 x86 保留了 Port I/O（IN/OUT 指令） |

> 易错提醒：
> 
> - 统一编址=**存储器映射 I/O（MMIO）**。
> - 独立编址下，为区分“访存 vs 访 I/O”，**必须有 I/O 专用控制信号**或专用总线周期。

# 六、接口类型的常见分类（知道点名词就行）

- 按**数据传送**：**并行**接口 / **串行**接口（USB 典型串行；主机侧“只能并行”是老教材观念，现代也有串行）。
- 按**控制方式**：**程序查询** / **中断** / **DMA** 接口（后面小节会细抠）。
- 按**可编程性**：可编程接口 / 不可编程接口。

# 七、命令字、状态字、数据字 & 中断类型号（常被细问）

- **命令字**：CPU→接口→设备（“该干啥”）。
- **状态字**：设备→接口→CPU（忙/就绪/错误/完成）。
- **数据字**：真正要传的输入/输出数据。
- **中断类型号**：告诉 CPU “这是哪个事件的中断”（完成？错误？哪路设备？）。

# 八、常见易错点

- *主机侧一定并行？**不一定（现代很多总线已串行化）。
- *状态/控制为何能合一？**命令阶段→寄存器空出来供状态回写，**时序互不冲突**。
- **数据总线只传数据？还可传命令字/状态字/中断类型号**。
- **接口可连多设备**：要么多组端口，要么地址里含设备号。
- **接口分类 ≠ 控制方式**：串行/并行是物理传输；查询/中断/DMA是主机控制策略。

# 九、两道快题（附答案）

1. **判断题**：采用**独立编址**时，CPU 可用 `ADD` 指令直接对某端口内容加 1。
    - **答**：**错**。独立编址必须用 I/O 专用指令（如 IN/OUT），无法拿普通算术访端口。
2. **选择**：下列说法正确的是：
    
    A. 统一编址下端口不占内存地址空间
    
    B. 独立编址下需 I/O 专用控制信号
    
    C. 统一编址下端口译码比独立编址更快
    
    D. 独立编址编程更灵活
    
    - **答**：**B**。A 错（会占用）；C 错（通常更慢）；D 错（更受限）。

## **程序查询（Polling / Programmed I/O）**

# 程序查询方式，一页速记

**1）它是啥？**

CPU 发起一次 I/O 后，**反复读状态寄存器**看设备是否就绪（RDY）。就绪→传1个字数据→继续查；未就绪→继续查（**忙等**）。也有“**定时查询**”版本：CPU隔固定时间去查一眼，期间做别的活。

**2）接口/端口模型（考点高频）**

- **数据端口（Data）**：收/发真正数据（可读/可写）。
- **状态端口（Status）**：反映 BUSY/RDY/ERR/FIN 等（只读）。
- **控制端口（Control/Command）**：写入命令字（只写）。
- 很多实现把**状态与控制合并**为一个端口：先写命令，随后同一端口被设备**回写状态**（时序错开，互不冲突）。
- 端口地址示例：**N**=数据端口；**N+1**=状态/控制端口。

**3）x86 指令怎么用？**

- `OUT port, rs`：把寄存器 **rs → 端口**。
- `IN rd, port`：从端口 **→ 寄存器 rd**。
    
    -（还有批量 `INS/OUTS`，你知道有这俩就行。）
    

**4）打印 3 个字符（A/B/C）的典型流程**

![image.png](assets/image%2055.png)

1. **写命令字**：`OUT N+1, cmd`（驱动把“启动打印”编码成 cmd）。
2. **轮询状态**：`loop: IN r0, N+1`；测试 `r0.RDY`。
3. **就绪→写数据**：`OUT N, data`（先 A，再 B，再 C）。
4. 全部完成后可**写停机命令**：`OUT N+1, stop_cmd`。

> 程序查询 = 命令→忙等查状态→一次数据→再查…
> 
> 
> 定时查询 = 每隔 T 查一次；期间 CPU 可干别的，但 **T 不能太大**（否则丢数据）。
> 

**5）性能/占用率一把抓（秒会算题）**

- **每次查询耗时**：`T_poll = cycles_per_poll / f_clk`。
- **每秒查询次数**：`Q`（由设备速率或你的策略决定）。
- **CPU 占用率**：`U = Q * T_poll`。
    - 若“**每传1字就查1次**”，而设备吞吐是 `R_word/s`，则 `Q = R`，所以
        
        **能支持的极限吞吐** `R_max ≈ 1 / T_poll`（超过就必爆表）。
        
- **定时查询不丢数条件**（有 FIFO 缓冲 B 个事件、到达率 r 事件/秒）：
    
    `T_period ≤ B / r`。否则覆盖丢数据。
    

**6）优缺点 & 适用**

- ✅ 硬件/接口**最简单**；软件可控；适合**极慢/偶发**设备（如按键、低速传感器），或初始化阶段。
- ❌ **CPU 浪费大**（独占查询更甚）；高吞吐设备**根本带不动**；多设备时易饿死他人。
- ↗️ 改进路径：**中断方式**（一次数据一次中断）→ **DMA**（批量搬+最后中断）→（大型机）**通道**。

**7）术语别混**

- “**查询**”=读状态；“**轮询**”常指**在多设备间轮着查**（round-robin）。
- `IN/OUT` 方向别写反；端口宽度（8/16/32 位）看具体平台。
- “主机侧总并行”是老教材说法；现代很多主机侧也可**串行**（PCIe/USB 等）。

---

## 快练 1：

![image.png](assets/image%2056.png)

已知：**每次查询 100 个时钟周期**，**f_clk = 50 MHz**。

- 每周期 20 ns → `T_poll = 100×20ns = 2000ns = 2µs`。

(1) **鼠标**：CPU 每秒查 **30 次**。

`U = 30 × 2µs = 60µs/s = 0.006%` ✅（几乎不占 CPU）。

(2) **磁盘**：每 **32 位**（1 字）查一次；要求吞吐使得**每秒需 2^19 次传送**。

`U = 2^19 × 2µs = 1,048,576µs ≈ 1.0486s/s ≈ 105%` ❌（忙不过来，达不到该吞吐）。

> 小结：慢设备可用查询；快设备必须上中断/DMA。
> 

## 快练 2：定时查询不卡壳

设备产生**2 KB/s**的 1 字节事件；接口有**32 字节 FIFO**。问**最大查询周期**？

`r = 2048 B/s, B = 32 B` → `T_period ≤ B/r = 32/2048 s = 1/64 s ≈ 15.625 ms`。

（取更小以留余量，常见做法配 **10 ms** 周期。）

## 中斷工作原理

# 中断基础

**中断是什么？**

CPU平时顺序执行指令。每条指令末尾**例行检查是否有中断请求(IRQ)**。若有且允许中断，则**暂时改道**，去执行该事件对应的**中断服务程序 ISR**；处理完再回到被打断处继续跑。

**几个名词**

- **中断源**：能发IRQ的部件（键盘、磁盘、时钟、DMA等）。
- **可屏蔽中断** vs **非屏蔽中断(NMI)**：大多数I/O是可屏蔽的；NMI（如掉电）**即使关中断也必须响应**。
- **PSW.IF（中断允许标志）**：IF=1 开中断；IF=0 关中断。
- **中断请求标记寄存器**：每位对应一个中断源，置1表示该源有请求。
- **硬件排队器(优先级编码器)**：对同时到来的多个IRQ做**硬件判优**，选出优先级最高的那个。
- **中断向量**：**ISR入口地址**（函数指针）。
- **向量地址/类型号**：**存放“中断向量”的地址**（指针的指针）。CPU先用“类型号”去向量表取到“向量”，再跳到ISR。

# CPU 处理一次中断：硬件到软件的完整链路

![image.png](assets/image%2057.png)

1. **指令末尾检测IRQ**（中断阶段）。若无→取下一条；有→继续。
2. **检查可否响应**：看 **IF**（以及是否NMI）。
3. **判优与识别**：硬件排队器确定**哪个源**；形成**中断类型号**（向量地址）。
4. **中断隐指令（CPU自动完成的一揽子动作）**
    
    ![image.png](assets/image%2058.png)
    
    - **关中断**（置IF=0，保证下面动作原子）。
    - **保存断点**：把 **PC(=下一条地址)**（通常连同PSW等）**压入内核栈**。
    - **取向量**：按“类型号”从**中断向量表**取出该中断的**ISR入口**
    - 。
    - **PC ← ISR入口**（程序流转向中断服务程序开头）。
5. **ISR执行（软件部分）**
    - **保护现场**：保存会用到的通用寄存器/ACC等到栈。
    - **处理中断**：如从设备数据端口读数据、清状态/应答等。
    - **恢复现场**：弹回寄存器。
    - **开中断**（IF=1；单重中断模型下放在返回前）。
    - **中断返回**：弹出先前保存的 **PC(=k+1)**，回到被打断的程序继续执行。

> 注：本节默认单重中断（处理ISR过程中不再响应新的IRQ）。多重/嵌套中断的开放位置与屏蔽规则是下一节的主角。
> 

# 为什么“关/开中断”要包住整个服务过程？

- 关中断 + 保存断点 + 取向量 + 进入ISR + … + 恢复 + 开中断
    
    → 把这段变成**原子区**：**不被再次打断**，确保断点、现场、返回一致性。
    
- **NMI 例外**：即使关中断，NMI仍然能进（如掉电）。

# 硬件向量法（超高频易混点）

![未命名.png](assets/%E6%9C%AA%E5%91%BD%E5%90%8D.png)

- 向量表里放的是**“JMP ISR入口”**或直接的**入口地址**。
- **向量地址/类型号**：索引向量表的地址（指针的指针）。
- 为什么不让硬件直接输出ISR入口？→ **ISR大小/位置会变**，**改表就行**，不用改硬件。

# 判优设计的常见规则（優先級从高到低）

1. **硬件故障/掉电**（NMI 类）
2. **软件中断/系统调用**（实现上常独立通道）
3. **DMA > 一般I/O**（高速优先）
4. **高速设备 > 低速设备**
5. **输入 > 输出**（输入缓冲更易溢出/丢失）
6. **实时设备 > 普通设备**

# 小练·速判（3题）

1. **IF=0 时，所有中断都不会被响应。**
    
    — 错。**NMI 仍会响应**。
    
2. **“中断向量”与“向量地址”是同一概念。**
    
    — 错。向量=ISR入口地址；向量地址/类型号=**存放向量的表项地址**。
    
3. **输入设备的IRQ优先于输出的一个原因是避免缓冲溢出/覆盖丢数。**
    
    — 对。
    

---

## 多重中斷

# 一、單重 vs. 多重中斷

- **單重中斷**：CPU 進入 ISR（中斷服務常式）後全程**不可再被中斷**。做法：中斷隱指令先 **關中斷**（IF=0），直到 ISR 結束才 **開中斷**。
- **多重中斷（可重入）**：允許 ISR 途中**再被更高優先級的中斷打斷**。做法：
    1. 進 ISR 先**保護現場**（推保存CS/IP/PSW與通用暫存器…）；
    2. 設定/保存**屏蔽字（IMR）**；
    3. **開中斷**（IF=1）允許更高優先級再進來；
    4. 回到尾聲前先 **關中斷**，**恢復現場**，最後 **IRET**。
    
    ![image.png](assets/image%2059.png)
    

> 為什麼「開中斷」要放在保護現場之後？
> 
> 
> 因為保護現場本身要連續完成；若中途被打斷，主程式/外層 ISR 的現場可能只存了一半而**損毀**。
> 
> 同理，**恢復現場前**要先關中斷，避免恢復到一半又被打斷。
> 

# 二、中斷屏蔽字（Interrupt Mask）

- **概念**：用位元遮罩「選擇性忽略」某些中斷請求，以**動態調整**優先次序。
    
    常見寄存器命名（以 8259A 為例）：
    
    **IRR**＝請求、**ISR**＝服務中、**IMR**＝屏蔽字。
    
- **習慣規則**：位元 **1=屏蔽**，**0=允許**。
    
    每個中斷源可有**自己的屏蔽字**（在處理它時生效）。
    
    **至少要自我屏蔽**（避免「自己中斷自己」的嵌套）。
    
- **固定優先 vs. 可屏蔽**：
    
    硬體排隊器給**固定**優先序；加上屏蔽功能後可**動態**改變「誰能打斷誰」。
    

# 三、8086/8259A 對照（幫助理解）

- 8086 重要腳位：**INTR**（可屏蔽中斷請求）、**NMI**（非屏蔽，必回應）、**IF**（PSW旗標，1=允許中斷）。
- 8259A：外設請求進 **IRR**→ 優先級裁決 → 產生**中斷型號**（經資料匯流排送給 CPU）→ CPU 依中斷向量表跳轉 ISR。
- 觀念題：**中斷向量**＝ISR 入口位址；**向量地址**＝存放「向量」的地址（像「指標的指標」）。

# 四、經典配題：用屏蔽字實現「D > A > C > B」

![image.png](assets/image%2060.png)

- 已知硬體**固定**優先：A > B > C > D。
- 希望**處理次序**（誰能打斷誰）：**D > A > C > B**。
- 屏蔽字（1=屏蔽、0=允許），位元順序示例用 **[A B C D]** 表：
    - 當處理 **A**：只能被 **D** 打斷 ⇒ 允許 D，屏蔽其餘與自身 → **A: [1 1 1 0]**
    - 當處理 **B**：可被 A/C/D 打斷，且自我屏蔽 → **B: [0 1 0 0]**
    - 當處理 **C**：可被 A/D 打斷，屏蔽 B 與自身 → **C: [0 1 1 0]**
    - 當處理 **D**：最高，誰都不能打斷（含自身） → **D: [1 1 1 1]**

# 五、時序題「畫 CPU 執行軌跡」解題模板

1. 先列**到達時刻**與**每個 ISR 執行時間**（本題每個 20 μs）。
2. 維護一個「目前執行的中斷源」，新請求來時：
    - 檢查**當前源的屏蔽字**是否允許被對方打斷；若允許，則**壓棧當前 ISR 的已執行時間**，轉去新 ISR。
3. 每個 ISR 完成就**彈回上一層**，繼續執行剩餘時間。
4. 直到所有 ISR 完成，畫出時間軸。

**舉例（與你貼文一致）**

到達：B @5、D @10、A @35、C @60（皆 20 μs）

- 5–10：執行 **B**（5 μs）
- 10–30：**D** 來且可打斷 B → 執行 **D** 完成
- 30–35：回 **B**（再 5 μs，累積 10 μs）
- 35–55：**A** 來且可打斷 B → 執行 **A** 完成
- 55–60：回 **B**（再 5 μs，累積 15 μs）
- 60–80：**C** 來且可打斷 B → 執行 **C** 完成
- 80–85：回 **B** 完成最後 5 μs
    
    **總結：**D 結束於 30、A 於 55、C 於 80、B 於 **85 μs**。
    

# 六、易考問答（一句話背下）

- **為何開中斷要在保存現場後？** 保障現場一致性，避免亂序破壞。
- **為何恢復前要先關中斷？** 防止恢復到一半再被打斷。
- **屏蔽字 1/0 表什麼？** 1=屏蔽、0=允許；至少自我屏蔽。
- **NMI vs. INTR？** NMI 不受 IF 影響必回應；INTR 受 IF 控制。
- **向量 vs. 向量地址？** 向量=ISR 入口；向量地址=存放該入口的地址。

## 程序中斷

# 核心流程

![image.png](assets/image%2061.png)

1. 程式用 I/O 指令**啟動外設** → 外設花時間準備資料。
2. 外設就緒 → 送 **INTR** → CPU 在指令週期末檢測到中斷。
3. **中斷響應（隱指令）**：關中斷、保存斷點(PSW/PC或CS:IP)… 取向量跳 ISR。
4. **ISR 開頭**：保存現場、保存/設置屏蔽字，必要時**開中斷**允許更高優先級嵌套。
5. **ISR 主體**：從 I/O 端口取字元；第 15 條指令**重新啟動外設**開始準備下一字元。
6. **ISR 尾聲**：關中斷、恢復現場、IRET 回到 **k+1**。
    
    → 因為在第 15 條就重啟外設，**CPU 與外設可流水並行**。
    

---

# 本題已知

![image.png](assets/image%2062.png)

- 主頻：對應時鐘 **T = 20 ns**（50 MHz）。
- **CPI = 4**。
- 外設準備一個字元時間：**0.5 ms** → 0.5 ms/20 ns=25,0000.5\text{ ms}/20\text{ ns}=25{,}000 週期。
- 中斷響應（隱指令）= **10** 週期。
- ISR 共 **20** 條指令；第 **15** 條啟動下一次 I/O。

---

## 1) 完成讀取 **1000** 個字元，共需多少「時鐘週期」？

思路：單個字元的**節拍**由三段串接決定

25,000⏟外設準備+10⏟響應+15×4⏟ISR 前 15 條=25,070 cycles/char\underbrace{25{,}000}_{\text{外設準備}}
+\underbrace{10}_{\text{響應}}
+\underbrace{15\times 4}_{\text{ISR 前 15 條}}
=25{,}070\ \text{cycles/char}

> 後面 5 條 ISR 指令（5×4=205\times4=20 週期）與「下一個字元的外設準備」重疊；只在最後一個字元是否加上 20 週期見解可兩種都算分。
> 
- **主解**：
    
    25,070×1000=25,070,000 cycles25{,}070\times 1000 = \boxed{25{,}070{,}000\ \text{cycles}}
    
- **嚴格加尾巴（可選）**：
    
    25,070,000+20=25,070,020 cycles25{,}070{,}000 + 20 = \boxed{25{,}070{,}020\ \text{cycles}}
    

（換算時間：約 25,070,000×20 ns≈0.5014 s25{,}070{,}000\times20\text{ ns}\approx 0.5014\ \text{s}）

---

## 2) CPU 為處理 **1000 次中斷**實際花了多少週期？

只算 CPU 的中斷開銷（不含外設準備）：

(10⏟響應+20×4⏟ISR 全部)×1000=(10+80)×1000=90,000 cycles( \underbrace{10}_{\text{響應}} + \underbrace{20\times4}_{\text{ISR 全部}} ) \times 1000
= (10+80)\times1000
=\boxed{90{,}000\ \text{cycles}}

（約 90,000×20 ns=1.8 ms90{,}000\times20\text{ ns}=1.8\text{ ms}）

---

## 3) 「中斷響應階段」CPU 做了哪些事？

精簡版（按典型 8086/8259A 思路）：

1. **關中斷**（IF=0）。
2. **保存斷點與狀態**（PSW/FLAGS、PC 或 CS:IP）。
3. 外部/中斷控制器給**中斷型號**（向量號），CPU 擷取**中斷向量** → 跳轉至 ISR 入口。

> 之後在 ISR：保存通用暫存器／屏蔽字→（可能）開中斷→處理 I/O→關中斷→恢復現場→IRET。
> 

---

## DMA

# 1. 為什麼要用 DMA？

- **中斷式 I/O**：外設每就緒 1 個**字**就讓 CPU 進 ISR「搬運一次」，高速裝置會把 CPU 拖進大量 ISR，效率差。
- **DMA（Direct Memory Access）**：交給 **DMA 控制器**成批（**一整塊**）搬資料；CPU只做**預處理**與**後處理**（塊完成才中斷一次）。
    
    → CPU 與外設、資料搬運可**並行**。
    

# 2. DMA 控制器（常見寄存器/模組）

- **AR**（Memory Address Register）：主存目的/來源位址（自動+Δ字節數）。
- **WC**（Word Count）：剩餘字數（自動–1；**溢出/到 0 觸發完成**）。
- **DR**（Data Buffer Register）：每字進/出的緩衝。
- **DAR**（Device Address，可選）：外設內部位址/扇區等。
- **控制/狀態邏輯**：方向（讀入/寫出）、產生 **R/W** 命令、位址/數據放上總線。
- **DMA 請求觸發器**：外設每送/取完 1 字就置位（「**DMA 請求**」）。
- **中斷機構**：整塊完成時對 CPU 發「**DMA 完成中斷**」。

> 名詞別混
> 
> - **DMA 請求**：每字一次，用來「要主存週期/總線」。
> - **DMA 中斷**：整塊結束一次，讓 CPU 做善後。

# 3. 一次「讀入」塊傳輸流程（精簡版）

![image.png](assets/image%2063.png)

**預處理（CPU）**：設方向=輸入、`AR` 起始址、`WC` 字數、（必要時 `DAR`/磁碟位址），啟動外設。

**每字循環（DMA）**：

1. 外設將 1 字放進 **DR**，拉高 DMA 請求。
2. DMA **申請總線**（典：`HRQ`），CPU 回應 `HLDA` → DMA 取得總線。
3. DMA 對主存發 **WRITE**，同時把位址放上地址線、資料放上數據線。
4. **AR+=字長**、**WC–1**。
    
    **完成**：`WC→0/溢出` → DMA 發**中斷**；CPU 進 ISR 做後處理，恢復主程式。
    

# 4. 總線/主存衝突的 3 種處理

![image.png](assets/image%2064.png)

1. **整塊佔用（Burst/Block Mode）**：DMA 佔滿到塊結束；**CPU停**，簡單但浪費。
2. **交錯分時（Interleaved/Time-slice）**：固定把主存週期分給 DMA/CPU（C1/C2 交替）；控制中等，利用率不一定好。
3. **週期挪用（Cycle Stealing）**：兩者同時要時，**優先給 DMA** 偷走單個主存週期；其餘時間 CPU 正常。最常考。

> 單總線 vs. 三總線
> 
> - **單總線**：是否給 DMA 用總線由 **CPU** 控制。
> - **三總線**（CPU–主存專用、DMA–主存專用、I/O 線）：**同時**可能想訪存，才需要上面 3 策略。

# 5. DMA vs. 中斷式 I/O（對比速表）

- **誰在搬**：中斷＝CPU 搬；DMA＝控制器硬體搬。
- **中斷頻率**：中斷＝每字一次；DMA＝每塊一次。
- **CPU 開銷**：中斷＝保存/恢復＋ISR 主體多次；DMA＝預處理＋完成一次 ISR。
- **適用裝置**：中斷＝低速；DMA＝高速/塊裝置（磁碟等）。
- **優先級**：DMA 完成中斷通常優先於慢速 I/O 中斷。
- **資料流**：兩者都走主存；DMA 還要總線仲裁。

# 6. 計算題模板（背這些就會算）

**(A) CPU 為 DMA 付出的週期數**

- 若題目只問「CPU 自己耗掉多少」：
    
    $T_{\text{CPU}} = T_{\text{預處理}} + T_{\text{後處理}} \quad(\text{通常僅 1 次})$
    
    若題目明給完成中斷 ISR 含 n 條指令、CPI、還有中斷響應開銷，照樣代入一次即可。
    

**(B) 週期挪用對 CPU 的影響**（記住這個比例思路）

- 設外設實際傳輸速率 $R_w$（字/秒），主存存取週期 $t_m$。
- **每秒被 DMA 偷走的主存週期數** $\approx R_w$。
- **被偷走的時鐘週期** $\approx R_w \cdot \frac{t_m}{T_{\text{clk}}}$。
- 若程式是**存取受限（mem-bound）**，CPU 可用的主存週期與效能按被偷比例下降。

**(C) 塊傳輸總時間**（裝置主導）

$T_{\text{總}} \approx N \cdot \max\{t_{\text{裝置出字}},\ t_m\}
\;+\; T_{\text{預/後處理}}$

- 若裝置每字都能即時供給，常由 **主存存取週期** 決定；反之由**裝置出字時間**決定。

**(D) 整塊佔用模式**

- CPU 等待時間 $\approx N \cdot t_m$（近似，不含仲裁常數），因為整段時間 CPU 取不到主存。

# 7. 易錯點

- **DMA 請求 ≠ DMA 中斷**（每字 vs. 每塊）。
- 憑題意區分是**單總線**（CPU 授權總線）還是**三總線**（才需要週期挪用/交錯分時等）。
- `WC` 變 0（或溢出）才觸發完成中斷；`AR`/`WC` 都是**硬體自動**增減。
- 高速情境下**DMA 完成中斷優先級較高**是合理設計（避免資料丟失）。

---